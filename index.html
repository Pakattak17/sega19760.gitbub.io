<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Shooter — LAN P2P (manual SDP) — Full</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;left:8px;top:8px;z-index:40;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;max-width:calc(100% - 16px)}
  .players{position:absolute;left:8px;top:96px;z-index:40;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;max-width:calc(100% - 16px);white-space:pre-line}
  .instructions{position:absolute;right:8px;top:8px;z-index:40;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;max-width:240px}
  .crosshair{position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;pointer-events:none;z-index:10}
  .crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
  .crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
  .crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
  #gameOver{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50;padding:16px;background:rgba(0,0,0,0.85);display:none;text-align:center;border-radius:10px}
  #gameOver img{width:180px;margin-top:8px}
  #network{position:absolute;left:8px;bottom:8px;z-index:40;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;max-width:calc(100% - 16px)}
  textarea{width:480px;height:120px;background:#111;color:#fff;border:1px solid #333;padding:6px;border-radius:6px}
  @media(max-width:640px){ textarea{width:calc(100vw - 32px)} .instructions{max-width:140px} .hud,.players,.instructions,#network{padding:6px} }
  button{padding:6px 10px;margin:4px;border-radius:8px;border:none;background:#222;color:#fff;cursor:pointer}
  input[type="text"]{padding:6px;border-radius:6px;border:1px solid #333;background:#111;color:#fff}
  label{font-size:13px}
</style>
</head>
<body>
<div id="container">
  <div class="hud" id="hud">Score: 0 | Enemies: 0 | HP: 1</div>

  <div class="players" id="players">Players: me</div>

  <div class="instructions">
    <strong>Controls</strong><br>
    WASD - move • Mouse - look • Click - shoot • Space - jump • Y - toggle view • Esc - release mouse • 1/2 - switch weapon
  </div>

  <div class="crosshair"></div>

  <div id="gameOver">
    <div style="font-size:22px">Game Over</div>
    <img src="backflip.gif" alt="backflip"><br>
    <button id="retry">Retry</button>
  </div>

  <div id="network">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>Name: <input id="nameInput" type="text" placeholder="Your name" style="width:160px"></label>
      <label>Host IP (display only): <input id="hostIp" type="text" placeholder="e.g. 25.x.x.x" style="width:140px"></label>
      <button id="btnHost">Host</button>
      <button id="btnJoin">Join</button>
      <button id="btnHide">Hide UI</button>
    </div>

    <!-- host UI -->
    <div id="hostControls" style="margin-top:8px;display:none">
      <div><button id="createOffer">Create Offer (for one joiner)</button> — after creating, copy & give Offer text</div>
      <div style="margin-top:6px">Offer (copy → give to joiner):</div>
      <textarea id="offerOut" readonly></textarea>
      <div style="margin-top:6px">Paste answer from joiner here:</div>
      <textarea id="answerIn" placeholder="paste joiner's answer JSON here"></textarea>
      <div><button id="acceptAnswer">Accept Answer</button></div>
    </div>

    <!-- join UI -->
    <div id="joinControls" style="margin-top:8px;display:none">
      <div>Paste host offer here:</div>
      <textarea id="offerIn" placeholder="paste host offer JSON here"></textarea>
      <div style="margin-top:6px"><button id="createAnswer">Create Answer</button> — copy the answer output to host</div>
      <div style="margin-top:6px">Answer (copy → send to host):</div>
      <textarea id="answerOut" readonly></textarea>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';

/* ---------- Scene & renderer ---------- */
const container = document.getElementById('container');
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a0a);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0.7,0);
const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight);
container.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,10,5); scene.add(dir);
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1e1e1e}));
ground.rotation.x = -Math.PI/2; scene.add(ground);

/* ---------- Game state ---------- */
const hud = document.getElementById('hud');
const playersDiv = document.getElementById('players');
const nameInput = document.getElementById('nameInput');
const hostIpInput = document.getElementById('hostIp');

const player = {
  pos:new THREE.Vector3(0,0.5,0),
  velocity:new THREE.Vector3(),
  speed:4,
  yaw:0,
  pitch:0,
  hp:1,
  alive:true,
  thirdPerson:false,
  weapon:1,
  jumpSpeed:5,
  canJump:true,
  id: Math.random().toString(36).slice(2,9),
  name: 'me'
};

const alexMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x6699ff}));
scene.add(alexMesh);

const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.8), new THREE.MeshStandardMaterial({color:0xffff00}));
camera.add(gun); gun.position.set(0,-0.1,-0.5);

/* ---------- Controls ---------- */
let keys = {};
window.addEventListener('keydown', e=>{
  keys[e.code] = true;
  if(e.code==='KeyY') player.thirdPerson = !player.thirdPerson;
  if(e.code==='Digit1') player.weapon = 1;
  if(e.code==='Digit2') player.weapon = 2;
});
window.addEventListener('keyup', e=> keys[e.code] = false);
window.addEventListener('keydown', e=>{ if(e.code==='Escape') document.exitPointerLock?.(); });
window.addEventListener('keydown', e=>{ if(e.code==='Space' && player.canJump){ player.velocity.y = player.jumpSpeed; player.canJump=false; }});

let isLocked=false;
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=> isLocked=(document.pointerLockElement===renderer.domElement));
document.addEventListener('mousemove', e=>{
  if(!isLocked) return;
  player.yaw -= e.movementX * 0.002;
  player.pitch -= e.movementY * 0.002;
  player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));
});

/* ---------- Enemies & bullets ---------- */
const ooferTemplate = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xff5555}));
const enemies=[]; const enemyGroup = new THREE.Group(); scene.add(enemyGroup);

function spawnEnemy(){
  const clone = ooferTemplate.clone();
  const angle = Math.random()*Math.PI*2; const dist = 10 + Math.random()*10;
  clone.position.set(Math.cos(angle)*dist, 0.5, Math.sin(angle)*dist);
  clone.userData = { hp: 2 };
  enemyGroup.add(clone); enemies.push(clone);
  updateHUD();
}

const bullets=[];

function shoot(){
  if(!player.alive) return;
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  const origin = player.thirdPerson ? player.pos.clone().add(new THREE.Vector3(0,0.7,0)) : camera.getWorldPosition(new THREE.Vector3());
  if(player.weapon===1){
    const b = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshStandardMaterial({color:0xffff00}));
    b.position.copy(origin); b.userData = { dir:dir.clone().normalize(), speed:12, weapon:1, owner:player.id };
    scene.add(b); bullets.push(b);
    sendData({t:'shoot',p:origin.toArray(),d:dir.toArray(),w:1});
  } else {
    const r = new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8), new THREE.MeshStandardMaterial({color:0xffaa00}));
    r.position.copy(origin); r.userData = { dir:dir.clone().normalize(), speed:8, weapon:2, owner:player.id };
    scene.add(r); bullets.push(r);
    sendData({t:'shoot',p:origin.toArray(),d:dir.toArray(),w:2});
  }
}
window.addEventListener('mousedown', e=>{ if(e.button===0) shoot(); });

/* ---------- HUD & Players ---------- */
let score = 0;
function updateHUD(){
  hud.textContent = `Score: ${score} | Enemies: ${enemies.length} | HP: ${player.hp} | Host IP: ${hostIpInput.value || 'N/A'}`;
}
function updatePlayers(){
  let text = `Players: ${player.name || 'me'}`;
  for(const id in remotePlayers){
    const r = remotePlayers[id];
    text += '\n' + (r.name || id);
  }
  playersDiv.textContent = text;
}

/* ---------- Game Over / Retry ---------- */
const gameOverDiv = document.getElementById('gameOver');
document.getElementById('retry').addEventListener('click', ()=>{
  // reset local player
  player.hp = 1; player.alive = true; player.pos.set(0,0.5,0); player.velocity.set(0,0,0);
  // clear bullets and enemies
  bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
  enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
  // reset spawn timing + score
  SPAWN_INTERVAL = 2500;
  lastSpawn = performance.now();
  score = 0;
  // broadcast reset to peers
  sendData({t:'reset'});
  gameOverDiv.style.display = 'none';
  updateHUD(); updatePlayers();
});

/* ---------- Networking (manual SDP P2P) ---------- */
const btnHost = document.getElementById('btnHost');
const btnJoin = document.getElementById('btnJoin');
const btnHide = document.getElementById('btnHide');
const hostControls = document.getElementById('hostControls');
const joinControls = document.getElementById('joinControls');
const createOfferBtn = document.getElementById('createOffer');
const acceptAnswerBtn = document.getElementById('acceptAnswer');
const createAnswerBtn = document.getElementById('createAnswer');
const offerOut = document.getElementById('offerOut');
const answerIn = document.getElementById('answerIn');
const offerIn = document.getElementById('offerIn');
const answerOut = document.getElementById('answerOut');

let peerConnections = {}; // id -> RTCPeerConnection
let dataChannels = {};    // id -> DataChannel
let remotePlayers = {};   // id -> state
let nextPeerIndex = 1;
let menuOpen = false;     // when true, game is paused

function setMenuOpen(open){
  menuOpen = open;
  // when menu open, pause game updates (we use menuOpen in gameTick)
  // visually show/hide network area via display
  // handled by host/join UI toggles
}

/* hide/show network UI */
btnHide.onclick = ()=>{
  const networkDiv = document.getElementById('network');
  if(networkDiv.style.display === 'none'){
    networkDiv.style.display = 'block';
    setMenuOpen(true);
    btnHide.textContent = 'Hide UI';
  } else {
    networkDiv.style.display = 'block'; // keep network area visible; hide button actually collapses the host/join panels
    // toggle host/join panels collapsed
    const currentlyVisible = (hostControls.style.display !== 'none') || (joinControls.style.display !== 'none');
    if(currentlyVisible){
      hostControls.style.display = 'none';
      joinControls.style.display = 'none';
      setMenuOpen(false);
      btnHide.textContent = 'Show UI';
    } else {
      // show default network top row
      setMenuOpen(true);
      btnHide.textContent = 'Hide UI';
    }
  }
};

/* host / join mode toggles */
btnHost.onclick = ()=>{
  hostControls.style.display = 'block';
  joinControls.style.display = 'none';
  btnHost.disabled = true; btnJoin.disabled = true;
  setMenuOpen(true);
  // show / set name
  player.name = nameInput.value || 'Host';
  updatePlayers();
  // optionally allow host to display IP typed
  updateHUD();
};
btnJoin.onclick = ()=>{
  joinControls.style.display = 'block';
  hostControls.style.display = 'none';
  btnHost.disabled = true; btnJoin.disabled = true;
  setMenuOpen(true);
  player.name = nameInput.value || 'Player';
  updatePlayers();
};

/* create a new RTCPeerConnection and prepare handlers */
function makePeer(id){
  const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  pc.onicecandidate = ev=>{
    // nothing required on each candidate for manual flow — we rely on SDP after a small timeout
  };
  pc.ondatachannel = ev=>{
    setupDataChannel(id, ev.channel);
  };
  return pc;
}
function setupDataChannel(id, ch){
  dataChannels[id] = ch;
  ch.onopen = ()=>{ console.log('DC open', id); };
  ch.onmessage = ev=>{
    try{
      const msg = JSON.parse(ev.data);
      handleRemoteMessage(id, msg);
    }catch(e){}
  };
  ch.onclose = ()=>{ console.log('DC closed', id); delete dataChannels[id]; delete peerConnections[id]; delete remotePlayers[id]; updatePlayers(); };
}

/* For host: create an offer for one joiner (creates a new peer slot) */
createOfferBtn.onclick = async ()=>{
  const peerId = 'peer' + (nextPeerIndex++);
  const pc = makePeer(peerId);
  peerConnections[peerId] = pc;
  const ch = pc.createDataChannel('game');
  setupDataChannel(peerId, ch);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // wait a bit for ICE candidates to gather (best-effort)
  setTimeout(()=> {
    offerOut.value = JSON.stringify(pc.localDescription);
    alert('Offer created. Copy "Offer" text and give to joiner. When joiner returns an Answer, paste it into "Paste answer" and click Accept Answer.');
  }, 700);
};

/* Host accepts the joiner's answer for the last created peer */
acceptAnswerBtn.onclick = async ()=>{
  const txt = answerIn.value.trim();
  if(!txt){ alert('Paste joiner answer first'); return; }
  const ids = Object.keys(peerConnections);
  if(ids.length===0){ alert('No pending offer — create offer first'); return; }
  const lastId = ids[ids.length-1];
  const pc = peerConnections[lastId];
  try{
    const remoteDesc = JSON.parse(txt);
    await pc.setRemoteDescription(remoteDesc);
    alert('Answer accepted. Connection should establish shortly.');
    answerIn.value = '';
    // after connection opens, datachannel will be ready and peers will exchange states automatically
  }catch(err){ alert('Could not set remote description: ' + err); }
};

/* Joiner creates answer from host offer */
createAnswerBtn.onclick = async ()=>{
  const txt = offerIn.value.trim();
  if(!txt){ alert('Paste host offer first'); return; }
  try{
    const remoteDesc = JSON.parse(txt);
    const pc = makePeer('host');
    peerConnections['host'] = pc;
    pc.ondatachannel = ev=> setupDataChannel('host', ev.channel);
    await pc.setRemoteDescription(remoteDesc);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    setTimeout(()=> {
      answerOut.value = JSON.stringify(pc.localDescription);
      alert('Answer created. Copy Answer text and send it back to the host.');
    }, 700);
  }catch(err){ alert('Invalid offer or error: ' + err); }
};

/* sendData: broadcast to all open channels */
function sendData(obj){
  const s = JSON.stringify(obj);
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(ch && ch.readyState === 'open'){
      try{ ch.send(s); } catch(e){}
    }
  }
}

/* handle messages from peers */
function handleRemoteMessage(id, msg){
  if(msg.t === 'state'){
    if(!remotePlayers[id]) remotePlayers[id] = {id:id, pos:new THREE.Vector3(), yaw:0, pitch:0, name: msg.name || id};
    const rp = remotePlayers[id];
    rp.pos.set(msg.p[0], msg.p[1], msg.p[2]);
    rp.yaw = msg.y; rp.pitch = msg.r; rp.hp = msg.hp; rp.name = msg.name || id;
    updatePlayers();
  }
  if(msg.t === 'shoot'){
    const pos = new THREE.Vector3(msg.p[0], msg.p[1], msg.p[2]);
    const dir = new THREE.Vector3(msg.d[0], msg.d[1], msg.d[2]);
    const bullet = new THREE.Mesh(new THREE.SphereGeometry(msg.w===1?0.1:0.3,8,8), new THREE.MeshStandardMaterial({color: msg.w===1?0xffff00:0xffaa00}));
    bullet.position.copy(pos); bullet.userData={dir:dir.clone().normalize(),speed: msg.w===1?12:8,weapon:msg.w,owner:id};
    scene.add(bullet); bullets.push(bullet);
  }
  if(msg.t === 'reset'){
    // peer requested reset — clear local enemies/bullets/score
    bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
    enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
    SPAWN_INTERVAL = 2500; lastSpawn = performance.now(); score = 0; updateHUD();
  }
}

/* periodic state send (only when channels open) */
setInterval(()=>{
  const s = {
    t:'state',
    id: player.id,
    p: [player.pos.x, player.pos.y, player.pos.z],
    y: player.yaw,
    r: player.pitch,
    hp: player.hp,
    name: nameInput.value || player.name
  };
  sendData(s);
}, 80);

/* ---------- Game logic (movement fixed) ---------- */
function updatePlayer(dt){
  // CORRECT forward & right vectors so W moves forward
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  let move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyA']) move.sub(right);
  if(keys['KeyD']) move.add(right);
  if(move.lengthSq()>0) move.normalize();
  player.velocity.x = move.x * player.speed;
  player.velocity.z = move.z * player.speed;

  // gravity & position integration
  player.velocity.y -= 9.8 * dt;
  player.pos.add(player.velocity.clone().multiplyScalar(dt));
  if(player.pos.y <= 0.5){ player.pos.y = 0.5; player.velocity.y = 0; player.canJump = true; }

  // camera update
  if(player.thirdPerson){
    alexMesh.visible = true;
    const distance = 5;
    const phi = Math.PI/2 + player.pitch;
    const theta = player.yaw;
    const camX = player.pos.x + distance * Math.sin(phi) * Math.sin(theta);
    const camY = player.pos.y + distance * Math.cos(phi);
    const camZ = player.pos.z + distance * Math.sin(phi) * Math.cos(theta);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(player.pos.x, player.pos.y + 0.7, player.pos.z);
  } else {
    alexMesh.visible = false;
    camera.position.copy(player.pos.clone().add(new THREE.Vector3(0,0.7,0)));
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
  }

  alexMesh.position.copy(player.pos);
  alexMesh.rotation.y = player.yaw;
}

function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      const dist = b.position.distanceTo(e.position);
      if(dist < 0.6 || (b.userData.weapon===2 && dist < 1.5)){
        e.userData.hp--;
        if(e.userData.hp<=0){ enemyGroup.remove(e); enemies.splice(j,1); score+=10; updateHUD(); }
        if(b.userData.weapon===1){ scene.remove(b); bullets.splice(i,1); break; }
        if(b.userData.weapon===2){
          for(let k=enemies.length-1;k>=0;k--){
            const e2 = enemies[k];
            if(e2.position.distanceTo(b.position) < 1.5){ e2.userData.hp--; if(e2.userData.hp<=0){ enemyGroup.remove(e2); enemies.splice(k,1); score+=10; updateHUD(); } }
          }
          scene.remove(b); bullets.splice(i,1); break;
        }
      }
    }
  }
}

function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    const dir = new THREE.Vector3().subVectors(player.pos, e.position); dir.y = 0;
    const dist = dir.length(); dir.normalize();
    e.position.add(dir.multiplyScalar(1.2 * dt));
    if(dist < 1.0 && player.alive){ player.hp = 0; player.alive = false; updateHUD(); gameOverDiv.style.display = 'block'; }
  }
}

/* render remote players */
function renderRemotes(){
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp.mesh){
      rp.mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xffaa66}));
      scene.add(rp.mesh);
    }
    if(rp.pos) rp.mesh.position.copy(rp.pos);
    rp.mesh.rotation.y = rp.yaw || 0;
  }
}

/* spawn timer */
let lastSpawn = performance.now();
let SPAWN_INTERVAL = 2500;

/* pause logic: when menuOpen true, don't update game physics */
function gameTick(now){
  const dt = Math.min(0.05, (now - (gameTick.last||now)) / 1000);
  gameTick.last = now;

  // do not progress game when network menu is actively open (paused)
  // if host/join panels or top network UI is being interacted with, menuOpen is true
  if(!menuOpen){
    if(now - lastSpawn > SPAWN_INTERVAL){ lastSpawn = now; spawnEnemy(); if(SPAWN_INTERVAL > 500) SPAWN_INTERVAL *= 0.995; }
    if(player.alive){ updatePlayer(dt); updateBullets(dt); updateEnemies(dt); }
    renderRemotes();
  }

  updateHUD(); updatePlayers();
  renderer.render(scene, camera);
  requestAnimationFrame(gameTick);
}
requestAnimationFrame(gameTick);

/* allow toggling menuOpen when showing/hiding host/join controls */
hostControls.style.display = 'none';
joinControls.style.display = 'none';
setMenuOpen(false);

/* when any network UI is displayed we consider the menu open (paused) */
const networkTop = document.getElementById('network');
function showHostUI(){
  hostControls.style.display = 'block';
  joinControls.style.display = 'none';
  setMenuOpen(true);
}
function showJoinUI(){
  joinControls.style.display = 'block';
  hostControls.style.display = 'none';
  setMenuOpen(true);
}
/* wire top buttons to these functions earlier (we already did) */
btnHost.onclick = showHostUI;
btnJoin.onclick = showJoinUI;

/* small helper to immediately update HUD & players if name changes */
nameInput.addEventListener('change', ()=>{ player.name = nameInput.value || player.name; updatePlayers(); });

/* expose internals for debugging */
window._peers = peerConnections;
window._dcs = dataChannels;
window._remote = remotePlayers;
window._send = sendData;

</script>
</body>
</html>
