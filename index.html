<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Shooter — LAN P2P (manual SDP)</title>
<style>
  :root{--bg:#000;--ui-bg:rgba(0,0,0,0.35);--btn:#222}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;left:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px);font-size:14px}
  .players{position:absolute;left:8px;top:96px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px);white-space:pre-line;font-size:13px}
  .instructions{position:absolute;right:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:260px;font-size:13px}
  .crosshair{position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;pointer-events:none;z-index:40}
  .crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
  .crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
  .crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
  #gameOver{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;padding:16px;background:rgba(0,0,0,0.9);display:none;text-align:center;border-radius:10px}
  #network{position:absolute;left:8px;bottom:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px)}
  textarea{width:480px;height:120px;background:#111;color:#fff;border:1px solid #333;padding:6px;border-radius:6px;resize:vertical}
  @media(max-width:640px){ textarea{width:calc(100vw - 32px)} .instructions{max-width:140px;font-size:12px} .hud,.players,.instructions,#network{padding:6px;font-size:13px} }
  button{padding:6px 10px;margin:4px;border-radius:8px;border:none;background:var(--btn);color:#fff;cursor:pointer}
  input[type="text"]{padding:6px;border-radius:6px;border:1px solid #333;background:#111;color:#fff}
  label{font-size:13px;margin-right:8px}
  .small{font-size:12px}
</style>
</head>
<body>
<div id="container">
  <div class="hud" id="hud">Score: 0 | Enemies: 0 | HP: 1 | Host IP: N/A</div>

  <div class="players" id="players">Players: me</div>

  <div class="instructions">
    <strong>Controls</strong><br>
    WASD - move<br>Mouse - look<br>Click - shoot<br>Space - jump<br>Y - toggle view<br>Esc - release mouse<br>1/2 - switch weapon
  </div>

  <div class="crosshair"></div>

  <div id="gameOver">
    <div style="font-size:20px">Game Over</div>
    <img src="backflip.gif" alt="backflip" style="width:180px">
    <br><button id="retry">Retry</button>
  </div>

  <div id="network">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>Name: <input id="nameInput" type="text" placeholder="Your name" style="width:140px"></label>
      <label>Host IP (display only): <input id="hostIp" type="text" placeholder="e.g. 25.x.x.x" style="width:140px"></label>
      <button id="btnHost">Host</button>
      <button id="btnJoin">Join</button>
      <button id="btnHide">Hide UI</button>
    </div>

    <div id="hostControls" style="margin-top:8px;display:none">
      <div><button id="createOffer">Create Offer (for a joiner)</button></div>
      <div style="margin-top:6px">Offer (copy → give to joiner):</div>
      <textarea id="offerOut" readonly placeholder="Offer will appear here..."></textarea>
      <div style="margin-top:6px">Paste Answer from joiner:</div>
      <textarea id="answerIn" placeholder="Paste joiner's answer JSON here"></textarea>
      <div><button id="acceptAnswer">Accept Answer</button></div>
    </div>

    <div id="joinControls" style="margin-top:8px;display:none">
      <div>Paste Host Offer here:</div>
      <textarea id="offerIn" placeholder="Paste host offer JSON here"></textarea>
      <div style="margin-top:6px"><button id="createAnswer">Create Answer</button></div>
      <div style="margin-top:6px">Answer (copy → send to host):</div>
      <textarea id="answerOut" readonly placeholder="Answer will appear here..."></textarea>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';

/* -------------------------
   Scene + basic game setup
   ------------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a0a);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0.7,0);
const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight); container.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,10,5); scene.add(dir);
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1e1e1e})); ground.rotation.x=-Math.PI/2; scene.add(ground);

/* HUD elements */
const hud = document.getElementById('hud');
const playersDiv = document.getElementById('players');
const nameInput = document.getElementById('nameInput');
const hostIpInput = document.getElementById('hostIp');

/* Player */
const player = {
  pos: new THREE.Vector3(0,0.5,0),
  velocity: new THREE.Vector3(),
  speed: 4,
  yaw: 0,
  pitch: 0,
  hp: 1,
  alive: true,
  thirdPerson: false,
  weapon: 1,
  jumpSpeed: 5,
  canJump: true,
  id: Math.random().toString(36).slice(2,9),
  name: 'me'
};

const alexMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x6699ff})); scene.add(alexMesh);
const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.8), new THREE.MeshStandardMaterial({color:0xffff00})); camera.add(gun); gun.position.set(0,-0.1,-0.5);

/* Controls */
let keys = {};
window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='KeyY') player.thirdPerson = !player.thirdPerson; if(e.code==='Digit1') player.weapon=1; if(e.code==='Digit2') player.weapon=2; });
window.addEventListener('keyup', e=>{ keys[e.code]=false; });
window.addEventListener('keydown', e=>{ if(e.code==='Escape') document.exitPointerLock?.(); });
window.addEventListener('keydown', e=>{ if(e.code==='Space' && player.canJump){ player.velocity.y = player.jumpSpeed; player.canJump=false; }});
let isLocked = false;
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=> isLocked = (document.pointerLockElement === renderer.domElement));
document.addEventListener('mousemove', e=>{ if(!isLocked) return; player.yaw -= e.movementX*0.002; player.pitch -= e.movementY*0.002; player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch)); });

/* Enemies & bullets */
const ooferTemplate = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xff5555}));
const enemies=[]; const enemyGroup = new THREE.Group(); scene.add(enemyGroup);
function spawnEnemy(){ const clone = ooferTemplate.clone(); const angle=Math.random()*Math.PI*2; const dist=10+Math.random()*10; clone.position.set(Math.cos(angle)*dist,0.5,Math.sin(angle)*dist); clone.userData={hp:2}; enemyGroup.add(clone); enemies.push(clone); updateHUD(); }

const bullets=[]; function shoot(){ if(!player.alive) return; const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); const origin = player.thirdPerson ? player.pos.clone().add(new THREE.Vector3(0,0.7,0)) : camera.getWorldPosition(new THREE.Vector3()); if(player.weapon===1){ const b = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshStandardMaterial({color:0xffff00})); b.position.copy(origin); b.userData={dir:dir.clone().normalize(),speed:12,weapon:1,owner:player.id}; scene.add(b); bullets.push(b); sendData({t:'shoot',p:origin.toArray(),d:dir.toArray(),w:1}); } else { const r = new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8), new THREE.MeshStandardMaterial({color:0xffaa00})); r.position.copy(origin); r.userData={dir:dir.clone().normalize(),speed:8,weapon:2,owner:player.id}; scene.add(r); bullets.push(r); sendData({t:'shoot',p:origin.toArray(),d:dir.toArray(),w:2}); } }
window.addEventListener('mousedown', e=>{ if(e.button===0) shoot(); });

/* HUD update */
let score = 0;
function updateHUD(){ hud.textContent = `Score: ${score} | Enemies: ${enemies.length} | HP: ${player.hp} | Host IP: ${hostIpInput.value || 'N/A'}`; }
function updatePlayers(){ let txt = `Players: ${nameInput.value || player.name || 'me'}`; for(const id in remotePlayers){ const r = remotePlayers[id]; txt += '\n' + (r.name || id); } playersDiv.textContent = txt; }

/* Game Over / Retry */
const gameOverDiv = document.getElementById('gameOver');
document.getElementById('retry').addEventListener('click', ()=>{
  // reset player
  player.hp = 1; player.alive = true; player.pos.set(0,0.5,0); player.velocity.set(0,0,0);
  // clear bullets & enemies and reset spawn
  bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
  enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
  SPAWN_INTERVAL = 2500; lastSpawn = performance.now(); score = 0;
  // broadcast reset to peers
  sendData({t:'reset'});
  gameOverDiv.style.display = 'none';
  updateHUD(); updatePlayers();
});

/* --------------------------
   Networking: manual SDP P2P
   -------------------------- */
const btnHost = document.getElementById('btnHost');
const btnJoin = document.getElementById('btnJoin');
const btnHide = document.getElementById('btnHide');
const hostControls = document.getElementById('hostControls');
const joinControls = document.getElementById('joinControls');
const createOfferBtn = document.getElementById('createOffer');
const acceptAnswerBtn = document.getElementById('acceptAnswer');
const createAnswerBtn = document.getElementById('createAnswer');
const offerOut = document.getElementById('offerOut');
const answerIn = document.getElementById('answerIn');
const offerIn = document.getElementById('offerIn');
const answerOut = document.getElementById('answerOut');

let peerConnections = {}; // peerId -> RTCPeerConnection
let dataChannels = {};    // peerId -> DataChannel
let remotePlayers = {};   // peerId -> state
let nextPeerIndex = 1;
let menuOpen = false;

/* pause when menu open */
function setMenuOpen(open){
  menuOpen = open;
}

/* Hide/Show UI behavior */
btnHide.onclick = ()=>{
  const networkDiv = document.getElementById('network');
  if(networkDiv.style.height === '24px'){
    networkDiv.style.height = '';
    btnHide.textContent = 'Hide UI';
    setMenuOpen(true);
  } else {
    // collapse host/join controls only (keep top row)
    hostControls.style.display = 'none';
    joinControls.style.display = 'none';
    setMenuOpen(false);
    btnHide.textContent = 'Show UI';
  }
};

/* Host / Join mode toggles */
btnHost.onclick = ()=>{
  hostControls.style.display = 'block';
  joinControls.style.display = 'none';
  btnHost.disabled = true; btnJoin.disabled = true;
  setMenuOpen(true);
  player.name = nameInput.value || 'Host';
  updatePlayers();
};
btnJoin.onclick = ()=>{
  joinControls.style.display = 'block';
  hostControls.style.display = 'none';
  btnHost.disabled = true; btnJoin.disabled = true;
  setMenuOpen(true);
  player.name = nameInput.value || 'Player';
  updatePlayers();
};

/* helper to make a new RTCPeerConnection */
function makePeer(peerId){
  const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  pc.onicecandidate = ev=>{
    // we rely on SDP after a small timeout; ICE candidates may still trickle but manual flow often works on LAN/Hamachi
  };
  pc.ondatachannel = ev=>{
    setupDataChannel(peerId, ev.channel);
  };
  return pc;
}

/* set up datachannel handlers */
function setupDataChannel(peerId, ch){
  dataChannels[peerId] = ch;
  ch.onopen = ()=>{ console.log('DataChannel open', peerId); };
  ch.onmessage = ev=>{
    try{
      const msg = JSON.parse(ev.data);
      handleRemoteMessage(peerId, msg);
    }catch(e){}
  };
  ch.onclose = ()=>{ console.log('DC closed', peerId); delete dataChannels[peerId]; delete peerConnections[peerId]; delete remotePlayers[peerId]; updatePlayers(); };
}

/* create offer (host creates one offer per joiner) */
createOfferBtn.onclick = async ()=>{
  const peerId = 'peer'+(nextPeerIndex++);
  const pc = makePeer(peerId);
  peerConnections[peerId] = pc;
  const ch = pc.createDataChannel('game');
  setupDataChannel(peerId, ch);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  setTimeout(()=>{ offerOut.value = JSON.stringify(pc.localDescription); alert('Offer created. Copy the Offer text and send to the joiner. After joiner sends their Answer paste it into "Paste Answer" and click Accept Answer.'); }, 700);
};

/* accept answer (host pastes joiner's answer for last created peer) */
acceptAnswerBtn.onclick = async ()=>{
  const txt = answerIn.value.trim();
  if(!txt){ alert('Paste joiner Answer first'); return; }
  const ids = Object.keys(peerConnections);
  if(ids.length===0){ alert('No pending offer — create Offer first'); return; }
  const lastId = ids[ids.length-1];
  const pc = peerConnections[lastId];
  try{
    const remoteDesc = JSON.parse(txt);
    await pc.setRemoteDescription(remoteDesc);
    answerIn.value = '';
    alert('Answer accepted. Connection should establish shortly.');
  }catch(err){ alert('Could not set remote description: '+err); }
};

/* joiner creates answer after pasting host offer */
createAnswerBtn.onclick = async ()=>{
  const txt = offerIn.value.trim();
  if(!txt){ alert('Paste host Offer first'); return; }
  try{
    const remoteDesc = JSON.parse(txt);
    const pc = makePeer('host');
    peerConnections['host'] = pc;
    pc.ondatachannel = ev=> setupDataChannel('host', ev.channel);
    await pc.setRemoteDescription(remoteDesc);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    setTimeout(()=>{ answerOut.value = JSON.stringify(pc.localDescription); alert('Answer created. Copy Answer text and send to host.'); }, 700);
  }catch(err){ alert('Invalid Offer or error: '+err); }
};

/* broadcast object to all open DCs */
function sendData(obj){
  const str = JSON.stringify(obj);
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(ch && ch.readyState === 'open'){
      try{ ch.send(str); }catch(e){}
    }
  }
}

/* handle incoming messages from peers */
function handleRemoteMessage(peerId, msg){
  if(msg.t === 'state'){
    if(!remotePlayers[peerId]) remotePlayers[peerId] = {id:peerId, pos:new THREE.Vector3(), yaw:0, pitch:0, name:msg.name||peerId};
    const rp = remotePlayers[peerId];
    rp.pos.set(msg.p[0], msg.p[1], msg.p[2]);
    rp.yaw = msg.y; rp.pitch = msg.r; rp.hp = msg.hp; rp.name = msg.name || peerId;
    updatePlayers();
  }
  if(msg.t === 'shoot'){
    const pos = new THREE.Vector3(msg.p[0], msg.p[1], msg.p[2]);
    const dir = new THREE.Vector3(msg.d[0], msg.d[1], msg.d[2]);
    const bullet = new THREE.Mesh(new THREE.SphereGeometry(msg.w===1?0.1:0.3,8,8), new THREE.MeshStandardMaterial({color: msg.w===1?0xffff00:0xffaa00}));
    bullet.position.copy(pos); bullet.userData={dir:dir.clone().normalize(), speed: msg.w===1?12:8, weapon: msg.w, owner: peerId};
    scene.add(bullet); bullets.push(bullet);
  }
  if(msg.t === 'reset'){
    bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
    enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
    SPAWN_INTERVAL = 2500; lastSpawn = performance.now(); score = 0; updateHUD();
  }
}

/* periodic state broadcast */
setInterval(()=>{
  const payload = { t:'state', id:player.id, p:[player.pos.x, player.pos.y, player.pos.z], y:player.yaw, r:player.pitch, hp:player.hp, name: nameInput.value || player.name };
  sendData(payload);
}, 80);

/* -------------------------
   Game logic & physics
   ------------------------- */
/* Movement vectors: CORRECT so W is forward */
function updatePlayer(dt){
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  let move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyA']) move.sub(right);
  if(keys['KeyD']) move.add(right);
  if(move.lengthSq()>0) move.normalize();
  player.velocity.x = move.x * player.speed;
  player.velocity.z = move.z * player.speed;

  // gravity & integrate
  player.velocity.y -= 9.8 * dt;
  player.pos.add(player.velocity.clone().multiplyScalar(dt));
  if(player.pos.y <= 0.5){ player.pos.y = 0.5; player.velocity.y = 0; player.canJump = true; }

  // camera
  if(player.thirdPerson){
    alexMesh.visible = true;
    const distance = 5;
    const phi = Math.PI/2 + player.pitch;
    const theta = player.yaw;
    const camX = player.pos.x + distance * Math.sin(phi) * Math.sin(theta);
    const camY = player.pos.y + distance * Math.cos(phi);
    const camZ = player.pos.z + distance * Math.sin(phi) * Math.cos(theta);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(player.pos.x, player.pos.y + 0.7, player.pos.z);
  } else {
    alexMesh.visible = false;
    camera.position.copy(player.pos.clone().add(new THREE.Vector3(0,0.7,0)));
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
  }

  alexMesh.position.copy(player.pos);
  alexMesh.rotation.y = player.yaw;
}

/* bullets & enemies update */
function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed * dt));
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      const dist = b.position.distanceTo(e.position);
      if(dist < 0.6 || (b.userData.weapon===2 && dist < 1.5)){
        e.userData.hp--;
        if(e.userData.hp<=0){ enemyGroup.remove(e); enemies.splice(j,1); score+=10; updateHUD(); }
        if(b.userData.weapon===1){ scene.remove(b); bullets.splice(i,1); break; }
        if(b.userData.weapon===2){
          for(let k=enemies.length-1;k>=0;k--){
            const e2 = enemies[k];
            if(e2.position.distanceTo(b.position) < 1.5){ e2.userData.hp--; if(e2.userData.hp<=0){ enemyGroup.remove(e2); enemies.splice(k,1); score+=10; updateHUD(); } }
          }
          scene.remove(b); bullets.splice(i,1); break;
        }
      }
    }
  }
}
function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    const dir = new THREE.Vector3().subVectors(player.pos, e.position); dir.y = 0;
    const dist = dir.length(); dir.normalize();
    e.position.add(dir.multiplyScalar(1.2 * dt));
    if(dist < 1.0 && player.alive){ player.hp = 0; player.alive = false; updateHUD(); gameOverDiv.style.display = 'block'; }
  }
}

/* render remote players */
function renderRemotes(){
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp.mesh){
      rp.mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xffaa66}));
      scene.add(rp.mesh);
    }
    if(rp.pos) rp.mesh.position.copy(rp.pos);
    rp.mesh.rotation.y = rp.yaw || 0;
  }
}

/* spawn timer */
let lastSpawn = performance.now();
let SPAWN_INTERVAL = 2500;

/* pause logic controlled by menuOpen */
function gameTick(now){
  const dt = Math.min(0.05, (now - (gameTick.last||now))/1000);
  gameTick.last = now;
  if(!menuOpen){
    if(now - lastSpawn > SPAWN_INTERVAL){ lastSpawn = now; spawnEnemy(); if(SPAWN_INTERVAL > 500) SPAWN_INTERVAL *= 0.995; }
    if(player.alive){ updatePlayer(dt); updateBullets(dt); updateEnemies(dt); }
    renderRemotes();
  }
  updateHUD(); updatePlayers();
  renderer.render(scene, camera);
  requestAnimationFrame(gameTick);
}
requestAnimationFrame(gameTick);

/* Expose debugging objects */
window._peers = peerConnections;
window._dcs = dataChannels;
window._remote = remotePlayers;
window._send = sendData;

</script>
</body>
</html>
