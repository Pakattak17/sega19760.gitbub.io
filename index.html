<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3D Shooter Fixed Controls</title>
<style>
html,body{height:100%;margin:0;background:#000;overflow:hidden}
#container{width:100%;height:100%;position:relative}
canvas{display:block}
.hud{position:absolute;left:10px;top:10px;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial;z-index:5;background:rgba(0,0,0,0.25);padding:8px 12px;border-radius:8px}
.crosshair{position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;z-index:4;pointer-events:none;mix-blend-mode:screen;opacity:0.9}
.crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
.crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
.crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
.instructions{position:absolute;right:10px;top:10px;color:#fff;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px}
.players{position:absolute;top:50px;left:10px;color:#fff;font-size:14px;background:rgba(0,0,0,0.25);padding:6px;border-radius:6px;z-index:6;}
#gameOver{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:30px;padding:20px;background:rgba(0,0,0,0.8);display:none;text-align:center;z-index:10;}
#retry{margin-top:10px;font-size:20px;padding:5px 10px;cursor:pointer;}
#gameOver img{width:200px;margin-top:10px;}
</style>
</head>
<body>
<div id="container">
  <div class="hud" id="hud">Score: 0 | Enemies: 0</div>
  <div class="players" id="players">Players:</div>
  <div class="instructions">WASD - move • Mouse - look • Click - shoot • Space: jump • Y - toggle view • Esc: release mouse • 1 2: switch weapon</div>
  <div class="crosshair"></div>
  <div id="gameOver">Game Over<br><img src="backflip.gif"><br><button id="retry">Retry</button></div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';

const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);

// Camera holder
const cameraHolder = new THREE.Object3D();
scene.add(cameraHolder);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0.7,0);
cameraHolder.add(camera);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
container.appendChild(renderer.domElement);

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Lights
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const dir = new THREE.DirectionalLight(0xffffff,0.8);
dir.position.set(-10,10,5);scene.add(dir);

// Ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1e1e1e}));
ground.rotation.x=-Math.PI/2; scene.add(ground);

// Player
const player = {pos:new THREE.Vector3(0,0.5,0),velocity:new THREE.Vector3(),speed:4,yaw:0,pitch:0,hp:1,alive:true,thirdPerson:false,weapon:1,jumpSpeed:5,canJump:true};

// Player cube
const alexMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x6699ff}));
scene.add(alexMesh);

// Gun
const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.8), new THREE.MeshStandardMaterial({color:0xffff00}));
camera.add(gun); gun.position.set(0,-0.1,-0.5);

// Controls
let keys={};
window.addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(e.code==='KeyY') player.thirdPerson=!player.thirdPerson;
  if(e.code==='Digit1') player.weapon=1;
  if(e.code==='Digit2') player.weapon=2;
});
window.addEventListener('keyup', e=>keys[e.code]=false);
window.addEventListener('keydown', e=>{if(e.code==='Escape') document.exitPointerLock?.();});

// Jump
window.addEventListener('keydown', e=>{
  if(e.code==='Space' && player.canJump){player.velocity.y = player.jumpSpeed; player.canJump=false;}
});

// Mouse look
let isLocked=false;
renderer.domElement.addEventListener('click',()=>{renderer.domElement.requestPointerLock?.();});
document.addEventListener('pointerlockchange',()=>{isLocked=(document.pointerLockElement===renderer.domElement);});
document.addEventListener('mousemove', e=>{
  if(!isLocked) return;
  player.yaw -= e.movementX*0.002;
  player.pitch -= e.movementY*0.002;
  player.pitch=Math.max(-Math.PI/2+0.1,Math.min(Math.PI/2-0.1,player.pitch));
});

// Enemies
const ooferTemplate = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xff5555}));
const enemies=[]; const enemyGroup=new THREE.Group(); scene.add(enemyGroup);
function spawnEnemy(){const clone = ooferTemplate.clone(); const angle = Math.random()*Math.PI*2; const dist = 10+Math.random()*10; clone.position.set(Math.cos(angle)*dist,0.5,Math.sin(angle)*dist); clone.userData={hp:2}; enemyGroup.add(clone); enemies.push(clone);}

// Bullets
const bullets=[];
function shoot(){
  if(!player.alive) return;
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  if(player.weapon===1){
    const bullet=new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8),new THREE.MeshStandardMaterial({color:0xffff00}));
    bullet.position.copy(camera.getWorldPosition(new THREE.Vector3()));
    bullet.userData={dir:dir.clone().normalize(),speed:12,weapon:1};
    scene.add(bullet); bullets.push(bullet);
  } else {
    const rpg=new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8),new THREE.MeshStandardMaterial({color:0xffaa00}));
    rpg.position.copy(camera.getWorldPosition(new THREE.Vector3()));
    rpg.userData={dir:dir.clone().normalize(),speed:8,weapon:2};
    scene.add(rpg); bullets.push(rpg);
  }
}
window.addEventListener('mousedown', e=>{if(e.button===0) shoot();});

// HUD
const hud = document.getElementById('hud');
const playersDiv = document.getElementById('players');
let score=0;
function updateHUD(){hud.textContent=`Score: ${score} | Enemies: ${enemies.length} | HP: ${player.hp}`;}
function updatePlayers(){playersDiv.textContent=`Players: me`;}

// Game Over
const gameOverDiv=document.getElementById('gameOver');
document.getElementById('retry').addEventListener('click', ()=>{
  player.hp=1; player.alive=true; player.pos.set(0,0.5,0);
  player.velocity.set(0,0,0);
  gameOverDiv.style.display='none'; updateHUD();
});

// Update player
function updatePlayer(dt){
  // Fixed forward/backward controls
  const forward = new THREE.Vector3(-Math.sin(player.yaw),0,-Math.cos(player.yaw));
  const right = new THREE.Vector3(Math.cos(player.yaw),0,-Math.sin(player.yaw));
  let move=new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyA']) move.sub(right);
  if(keys['KeyD']) move.add(right);
  if(move.lengthSq()>0) move.normalize();
  player.velocity.x = move.x*player.speed;
  player.velocity.z = move.z*player.speed;

  // Gravity
  player.velocity.y -= 9.8*dt;
  player.pos.add(player.velocity.clone().multiplyScalar(dt));
  if(player.pos.y<=0.5){player.pos.y=0.5; player.velocity.y=0; player.canJump=true;}

  // Camera
  if(player.thirdPerson){
    alexMesh.visible = true;
    const offset = new THREE.Vector3(Math.sin(player.yaw)*-5,3,Math.cos(player.yaw)*-5);
    cameraHolder.position.copy(player.pos.clone().add(offset));
    camera.lookAt(player.pos.clone().add(new THREE.Vector3(0,0.5,0)));
  } else {
    alexMesh.visible = false;
    cameraHolder.position.copy(player.pos);
    camera.position.set(0,0.7,0);
    camera.rotation.set(player.pitch,player.yaw,0,'YXZ');
  }
  alexMesh.position.copy(player.pos);
  alexMesh.rotation.y = player.yaw;
}

// Update bullets & enemies remain the same
function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed*dt));
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      const dist = b.position.distanceTo(e.position);
      if(dist<0.6 || (b.userData.weapon===2 && dist<1.5)){
        e.userData.hp--;
        if(e.userData.hp<=0){enemyGroup.remove(e);enemies.splice(j,1);score+=10;updateHUD();}
        if(b.userData.weapon===1){scene.remove(b); bullets.splice(i,1); break;}
        if(b.userData.weapon===2){
          for(let k=enemies.length-1;k>=0;k--){
            const e2 = enemies[k];
            if(e2.position.distanceTo(b.position)<1.5){e2.userData.hp--; if(e2.userData.hp<=0){enemyGroup.remove(e2);enemies.splice(k,1);score+=10;updateHUD();}}
          }
          scene.remove(b); bullets.splice(i,1); break;
        }
      }
    }
  }
}

function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    const dir = new THREE.Vector3().subVectors(player.pos,e.position); dir.y=0;
    const dist = dir.length(); dir.normalize();
    e.position.add(dir.multiplyScalar(1.2*dt));
    if(dist<1.0 && player.alive){player.hp=0;player.alive=false;updateHUD();gameOverDiv.style.display='block';}
  }
}

// Spawn timer
let lastSpawn=performance.now(); let SPAWN_INTERVAL=2500;
function gameTick(now){
  const dt=Math.min(0.05,(now-(gameTick.last||now))/1000); gameTick.last=now;
  if(now-lastSpawn>SPAWN_INTERVAL){lastSpawn=now; spawnEnemy(); updateHUD(); if(SPAWN_INTERVAL>500) SPAWN_INTERVAL *=0.97;}
  if(player.alive){updatePlayer(dt); updateBullets(dt); updateEnemies(dt);}
  renderer.render(scene,camera);
  requestAnimationFrame(gameTick);
}

updatePlayers(); updateHUD(); requestAnimationFrame(gameTick);
</script>
</body>
</html>
