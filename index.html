<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Discord Activity — 3D Shooter</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    #container{width:100%;height:100%;position:relative}
    canvas{display:block}
    .hud{
      position:absolute;left:10px;top:10px;color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial;z-index:5;
      background:rgba(0,0,0,0.25);padding:8px 12px;border-radius:8px
    }
    .crosshair{
      position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;z-index:4;
      pointer-events:none;mix-blend-mode:screen;opacity:0.9
    }
    .crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
    .crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
    .crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
    .instructions{position:absolute;right:10px;top:10px;color:#fff;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px}
    .players{position:absolute;top:50px;left:10px;color:#fff;font-size:14px;background:rgba(0,0,0,0.25);padding:6px;border-radius:6px;z-index:6;}
  </style>
</head>
<body>
  <div id="container">
    <div class="hud" id="hud">Score: 0 | Enemies: 0</div>
    <div class="players" id="players">Players:</div>
    <div class="instructions">WASD - move • Mouse - look • Click - shoot • Y - toggle view</div>
    <div class="crosshair"></div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';

    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0a);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,1.6,5);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    container.appendChild(renderer.domElement);

    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // lights
    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
    const dir = new THREE.DirectionalLight(0xffffff,0.8);
    dir.position.set(-10,10,5);scene.add(dir);

    // ground
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1e1e1e}));
    ground.rotation.x=-Math.PI/2; scene.add(ground);

    // player object
    const player = {
      pos:new THREE.Vector3(0,1.6,5), velocity:new THREE.Vector3(), speed:4, yaw:0, pitch:0,
      hp:1, alive:true, thirdPerson:false
    };

    // fallback model for alex
    const alexMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5,1,0.5), new THREE.MeshStandardMaterial({color:0x6699ff}));
    scene.add(alexMesh);

    let keys={};
    window.addEventListener('keydown',e=>{keys[e.code]=true;if(e.code==='KeyY'){player.thirdPerson=!player.thirdPerson;}});
    window.addEventListener('keyup',e=>keys[e.code]=false);

    // mouse look
    let isLocked=false;
    renderer.domElement.addEventListener('click',()=>{renderer.domElement.requestPointerLock?.();});
    document.addEventListener('pointerlockchange',()=>{isLocked=(document.pointerLockElement===renderer.domElement);});
    document.addEventListener('mousemove',e=>{
      if(!isLocked) return;
      player.yaw -= e.movementX*0.002;
      player.pitch -= e.movementY*0.002;
      player.pitch=Math.max(-Math.PI/2+0.1,Math.min(Math.PI/2-0.1,player.pitch));
    });

    // enemies
    const ooferTemplate=new THREE.Mesh(new THREE.BoxGeometry(0.6,1,0.6),new THREE.MeshStandardMaterial({color:0xff5555}));
    const enemies=[]; const enemyGroup=new THREE.Group(); scene.add(enemyGroup);

    function spawnEnemy(){
      const clone=ooferTemplate.clone();
      const angle=Math.random()*Math.PI*2;
      const dist=10+Math.random()*10;
      clone.position.set(Math.cos(angle)*dist,0.5,Math.sin(angle)*dist);
      clone.userData={hp:2};
      enemyGroup.add(clone);
      enemies.push(clone);
    }

    // projectiles
    const bullets=[];
    function shoot(){
      if(!player.alive) return;
      const geo=new THREE.SphereGeometry(0.1,8,8);
      const mat=new THREE.MeshStandardMaterial({color:0xffff00});
      const bullet=new THREE.Mesh(geo,mat);
      bullet.position.copy(player.pos);
      const dir=new THREE.Vector3(Math.sin(player.yaw)*Math.cos(player.pitch),-Math.sin(player.pitch),Math.cos(player.yaw)*Math.cos(player.pitch));
      bullet.userData={dir:dir.clone().normalize(),speed:12,owner:'me'};
      scene.add(bullet);
      bullets.push(bullet);
    }
    window.addEventListener('mousedown',e=>{if(e.button===0)shoot();});

    // HUD
    const hud=document.getElementById('hud');
    const playersDiv=document.getElementById('players');
    let score=0;
    function updateHUD(){hud.textContent=`Score: ${score} | Enemies: ${enemies.length} | HP: ${player.hp}`;}
    function updatePlayers(){playersDiv.textContent=`Players: me`;} // placeholder for usernames

    // update functions
    function updatePlayer(dt){
      const forward=new THREE.Vector3(Math.sin(player.yaw),0,Math.cos(player.yaw));
      const right=new THREE.Vector3(Math.cos(player.yaw),0,-Math.sin(player.yaw));
      let move=new THREE.Vector3();
      if(keys['KeyW']) move.add(forward);
      if(keys['KeyS']) move.sub(forward);
      if(keys['KeyA']) move.sub(right);
      if(keys['KeyD']) move.add(right);
      if(move.lengthSq()>0) move.normalize();
      player.velocity.copy(move.multiplyScalar(player.speed));
      player.pos.add(player.velocity.clone().multiplyScalar(dt));

      if(player.thirdPerson){
        camera.position.copy(player.pos.clone().add(new THREE.Vector3(Math.sin(player.yaw)*-3,2,Math.cos(player.yaw)*-3)));
        camera.lookAt(player.pos);
      } else {
        camera.position.copy(player.pos);
        camera.rotation.set(player.pitch,player.yaw,0,'YXZ');
      }

      alexMesh.position.copy(player.pos.clone().add(new THREE.Vector3(0,-0.8,0)));
    }

    function updateBullets(dt){
      for(let i=bullets.length-1;i>=0;i--){
        const b=bullets[i];
        b.position.add(b.userData.dir.clone().multiplyScalar(b.userData.speed*dt));
        for(let j=enemies.length-1;j>=0;j--){
          const e=enemies[j];
          if(b.position.distanceTo(e.position)<0.6){
            e.userData.hp--;
            if(e.userData.hp<=0){
              enemyGroup.remove(e);enemies.splice(j,1);score+=10;updateHUD();}
            scene.remove(b);bullets.splice(i,1);break;
          }
        }
      }
    }

    function updateEnemies(dt){
      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        const dir=new THREE.Vector3().subVectors(player.pos,e.position);dir.y=0;
        const dist=dir.length();dir.normalize();
        e.position.add(dir.multiplyScalar(1.2*dt));
        if(dist<1.0 && player.alive){
          player.hp=0;player.alive=false;updateHUD();alert('You died!');
        }
      }
    }

    // loop
    let lastSpawn=performance.now();
    const SPAWN_INTERVAL=2500;
    function gameTick(now){
      const dt=Math.min(0.05,(now-(gameTick.last||now))/1000);
      gameTick.last=now;
      if(now-lastSpawn>SPAWN_INTERVAL){lastSpawn=now;spawnEnemy();updateHUD();}
      if(player.alive){
        updatePlayer(dt);
        updateBullets(dt);
        updateEnemies(dt);
      }
      renderer.render(scene,camera);
      requestAnimationFrame(gameTick);
    }
    updatePlayers();updateHUD();
    requestAnimationFrame(gameTick);
  </script>
</body>
</html>
